---
phase: 01-security-fixes
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/validations/webhook.ts
  - src/app/api/webhooks/grow/route.ts
autonomous: true

must_haves:
  truths:
    - "Webhook rejects requests with invalid/missing signatures"
    - "Webhook rejects replay attacks (old timestamps)"
    - "parseInt/parseFloat handle NaN gracefully"
    - "Webhook payload is validated with Zod"
  artifacts:
    - path: "src/lib/validations/webhook.ts"
      provides: "Webhook payload Zod schema"
      exports: ["growWebhookSchema"]
      min_lines: 30
    - path: "src/app/api/webhooks/grow/route.ts"
      provides: "Secured webhook endpoint"
      contains: "verifyGrowWebhook"
      min_lines: 80
  key_links:
    - from: "src/app/api/webhooks/grow/route.ts"
      to: "src/lib/webhook-security.ts"
      via: "verifyGrowWebhook import"
      pattern: "from.*webhook-security"
---

<objective>
Secure the GROW webhook endpoint with signature verification and Zod validation.

Purpose: Prevent malicious webhook calls and ensure payment status updates are legitimate.
Output: Webhook endpoint with HMAC signature verification, replay protection, and Zod validation.
</objective>

<execution_context>
@/Users/itayostraich/.claude/get-shit-done/workflows/execute-plan.md
@/Users/itayostraich/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-fixes/01-CONTEXT.md
@.planning/phases/01-security-fixes/01-RESEARCH.md
@src/app/api/webhooks/grow/route.ts
@src/lib/webhook-security.ts (from Plan 01)
@src/lib/grow/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create webhook validation schema</name>
  <files>src/lib/validations/webhook.ts</files>
  <action>
Create `src/lib/validations/webhook.ts` with Zod schemas for GROW webhook payload.

Based on the existing WebhookPayload type in src/lib/grow/client.ts and current route.ts usage:

```typescript
import { z } from "zod";

/**
 * GROW webhook data schema
 * Uses z.coerce for numeric strings to handle NaN gracefully
 */
const webhookDataSchema = z.object({
  processId: z.string().min(1),
  processToken: z.string().min(1),
  transactionId: z.string().optional(),
  transactionToken: z.string().optional(),
  asmachta: z.string().optional(),
  statusCode: z.string(),
  cardSuffix: z.string().optional(),
  cardType: z.string().optional(),
  cardBrand: z.string().optional(),
  cardExp: z.string().optional(),
  // Use coerce to safely convert string to number, defaults to fallback on NaN
  paymentsNum: z
    .string()
    .transform((val) => {
      const num = parseInt(val, 10);
      return isNaN(num) ? 1 : num;
    })
    .optional()
    .default("1"),
  allPaymentsNum: z
    .string()
    .transform((val) => {
      const num = parseInt(val, 10);
      return isNaN(num) ? 1 : num;
    })
    .optional()
    .default("1"),
  firstPaymentSum: z
    .string()
    .transform((val) => {
      const num = parseFloat(val);
      return isNaN(num) ? null : num;
    })
    .optional()
    .nullable(),
  periodicalPaymentSum: z
    .string()
    .transform((val) => {
      const num = parseFloat(val);
      return isNaN(num) ? null : num;
    })
    .optional()
    .nullable(),
  customFields: z
    .object({
      cField1: z.string().optional(),
      cField2: z.string().optional(),
    })
    .optional(),
});

/**
 * Full GROW webhook payload schema
 */
export const growWebhookSchema = z.object({
  status: z.string(),
  data: webhookDataSchema,
  err: z.unknown().optional(),
});

export type GrowWebhookPayload = z.infer<typeof growWebhookSchema>;
export type GrowWebhookData = z.infer<typeof webhookDataSchema>;

/**
 * Safe number parser that returns default on NaN
 * Use this for any additional numeric conversions
 */
export function safeParseInt(value: string | undefined, defaultValue: number): number {
  if (!value) return defaultValue;
  const parsed = parseInt(value, 10);
  return isNaN(parsed) ? defaultValue : parsed;
}

export function safeParseFloat(value: string | undefined, defaultValue: number | null): number | null {
  if (!value) return defaultValue;
  const parsed = parseFloat(value);
  return isNaN(parsed) ? defaultValue : parsed;
}
```
  </action>
  <verify>
```bash
npx tsc --noEmit src/lib/validations/webhook.ts
grep -E "export (const|type|function)" src/lib/validations/webhook.ts
```
  </verify>
  <done>
- src/lib/validations/webhook.ts exists
- Exports growWebhookSchema, GrowWebhookPayload, safeParseInt, safeParseFloat
- Uses transform to handle NaN cases in numeric strings
- TypeScript compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Secure webhook endpoint</name>
  <files>src/app/api/webhooks/grow/route.ts</files>
  <action>
Update `src/app/api/webhooks/grow/route.ts` to add signature verification and Zod validation.

1. Add imports:
   - `verifyGrowWebhook`, `verifyGrowProcessToken` from `@/lib/webhook-security`
   - `growWebhookSchema` from `@/lib/validations/webhook`

2. Before parsing JSON, read raw body for signature verification:
   ```typescript
   // Get raw body for signature verification
   const rawBody = await request.text();

   // Verify webhook signature (if GROW_WEBHOOK_SECRET is configured)
   // Falls back to processToken validation if signature verification not available
   const headers = Object.fromEntries(request.headers.entries());
   const signatureResult = verifyGrowWebhook(rawBody, headers);

   if (!signatureResult.valid && process.env.GROW_WEBHOOK_SECRET) {
     // Log for debugging but don't reveal details in response
     console.error("[GROW Webhook] Signature verification failed:", signatureResult.error);
     return NextResponse.json(
       { error: "Unauthorized" },
       { status: 401 }
     );
   }
   ```

3. Parse and validate with Zod:
   ```typescript
   let body: unknown;
   try {
     body = JSON.parse(rawBody);
   } catch {
     console.error("[GROW Webhook] Invalid JSON");
     return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
   }

   const result = growWebhookSchema.safeParse(body);
   if (!result.success) {
     console.error("[GROW Webhook] Validation failed:", result.error.issues);
     return NextResponse.json({ error: "Invalid payload" }, { status: 400 });
   }

   const payload = result.data;
   ```

4. If signature not available, verify processToken against stored value:
   ```typescript
   if (!process.env.GROW_WEBHOOK_SECRET) {
     // Fallback: verify processToken matches stored payment
     const { data: payment } = await supabase
       .from("payments")
       .select("process_token")
       .eq("process_id", payload.data.processId)
       .single();

     if (!payment || !verifyGrowProcessToken(payload.data.processToken, payment.process_token)) {
       console.error("[GROW Webhook] ProcessToken mismatch");
       return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
     }
   }
   ```

5. Update the rest of the handler to use `payload` (validated data):
   - Remove `parseInt/parseFloat` calls - Zod already handles them with safe defaults
   - Use `payload.data.paymentsNum` directly (already a number)
   - Remove `as unknown as Json` cast - use proper typing

6. Remove the duplicate type definition for WebhookPayload (use the one from validations).

7. Keep the GET handler for connectivity testing.

Important:
- If GROW_WEBHOOK_SECRET is not set, fall back to processToken validation
- Log errors with context but return generic error messages
- Do NOT remove the approveTransaction call - GROW requires acknowledgment
  </action>
  <verify>
```bash
npx tsc --noEmit src/app/api/webhooks/grow/route.ts
grep "verifyGrowWebhook" src/app/api/webhooks/grow/route.ts
grep "growWebhookSchema.safeParse" src/app/api/webhooks/grow/route.ts
grep "parseInt" src/app/api/webhooks/grow/route.ts  # Should not appear
npm run lint -- --quiet
```
  </verify>
  <done>
- Webhook endpoint verifies signature before processing
- Webhook endpoint validates payload with Zod
- parseInt/parseFloat removed (handled by Zod transforms)
- Returns 401 for invalid signatures
- Returns 400 for invalid payloads
- Falls back to processToken validation if no webhook secret
- TypeScript and ESLint pass
  </done>
</task>

</tasks>

<verification>
1. Schema compiles: `npx tsc --noEmit src/lib/validations/webhook.ts`
2. Route compiles: `npx tsc --noEmit src/app/api/webhooks/grow/route.ts`
3. Signature verification: `grep "verifyGrowWebhook" src/app/api/webhooks/grow/route.ts`
4. Zod validation: `grep "safeParse" src/app/api/webhooks/grow/route.ts`
5. NaN handling: `grep -c "parseInt" src/app/api/webhooks/grow/route.ts` (should be 0)
6. Lint passes: `npm run lint`
</verification>

<success_criteria>
- src/lib/validations/webhook.ts exports growWebhookSchema with safe number parsing
- Webhook endpoint calls verifyGrowWebhook for signature verification
- Webhook endpoint uses Zod safeParse for validation
- No parseInt/parseFloat in route.ts (moved to Zod transforms)
- Returns 401 on signature failure, 400 on validation failure
- TypeScript and ESLint pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-fixes/01-04-SUMMARY.md`
</output>
