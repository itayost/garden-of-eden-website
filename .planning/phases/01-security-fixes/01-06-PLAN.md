---
phase: 01-security-fixes
plan: 06
type: tdd
wave: 3
depends_on: ["01-03", "01-04", "01-05"]
files_modified:
  - src/lib/__tests__/rate-limit.test.ts
  - src/lib/__tests__/webhook-security.test.ts
  - src/lib/validations/__tests__/payment.test.ts
  - src/lib/validations/__tests__/webhook.test.ts
autonomous: true

must_haves:
  truths:
    - "Rate limiting tests verify excessive requests are rejected"
    - "Webhook tests verify invalid signatures are rejected"
    - "Validation tests verify malformed input is rejected"
    - "All tests pass with npm run test"
  artifacts:
    - path: "src/lib/__tests__/rate-limit.test.ts"
      provides: "Rate limiting tests"
      contains: "checkRateLimit"
      min_lines: 40
    - path: "src/lib/__tests__/webhook-security.test.ts"
      provides: "Webhook security tests"
      contains: "verifyWebhookSignature"
      min_lines: 40
    - path: "src/lib/validations/__tests__/payment.test.ts"
      provides: "Payment validation tests"
      contains: "createPaymentSchema"
      min_lines: 50
  key_links:
    - from: "src/lib/__tests__/rate-limit.test.ts"
      to: "src/lib/rate-limit.ts"
      via: "Import rate limit utilities"
      pattern: "from.*rate-limit"
---

<objective>
Write tests for Phase 1 security features: rate limiting, webhook verification, and Zod validation.

Purpose: Verify security features work correctly and catch regressions.
Output: Test files for rate limiting, webhook security, and validation schemas.
</objective>

<execution_context>
@/Users/itayostraich/.claude/get-shit-done/workflows/execute-plan.md
@/Users/itayostraich/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-fixes/01-CONTEXT.md
@.planning/phases/01-security-fixes/01-RESEARCH.md
@.planning/codebase/TESTING.md
@src/lib/rate-limit.ts (from Plan 01)
@src/lib/webhook-security.ts (from Plan 01)
@src/lib/validations/payment.ts (from Plan 03)
@src/lib/validations/webhook.ts (from Plan 04)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create rate limiting tests</name>
  <files>src/lib/__tests__/rate-limit.test.ts</files>
  <action>
Create `src/lib/__tests__/rate-limit.test.ts` following project testing conventions (vitest).

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { isAdminExempt, getRateLimitIdentifier } from "../rate-limit";

// Note: checkRateLimit requires actual Redis connection
// These tests focus on the helper functions that don't need Redis

describe("rate-limit utilities", () => {
  describe("isAdminExempt", () => {
    it("should return true for admin role", () => {
      expect(isAdminExempt("admin")).toBe(true);
    });

    it("should return false for trainee role", () => {
      expect(isAdminExempt("trainee")).toBe(false);
    });

    it("should return false for trainer role", () => {
      expect(isAdminExempt("trainer")).toBe(false);
    });

    it("should return false for undefined role", () => {
      expect(isAdminExempt(undefined)).toBe(false);
    });

    it("should return false for null role", () => {
      expect(isAdminExempt(null as unknown as string)).toBe(false);
    });
  });

  describe("getRateLimitIdentifier", () => {
    it("should return user ID when authenticated", () => {
      expect(getRateLimitIdentifier("user-123", "192.168.1.1")).toBe("user-123");
    });

    it("should return IP prefix when not authenticated", () => {
      expect(getRateLimitIdentifier(null, "192.168.1.1")).toBe("ip:192.168.1.1");
    });

    it("should return IP prefix when user ID is empty", () => {
      expect(getRateLimitIdentifier("", "192.168.1.1")).toBe("ip:192.168.1.1");
    });

    it("should handle missing IP gracefully", () => {
      expect(getRateLimitIdentifier(null, "unknown")).toBe("ip:unknown");
    });
  });
});

// Integration test for checkRateLimit would require Redis mock
// This is a unit test file - integration tests can be added in Phase 9
```

If the rate-limit.ts module exports the limiter configurations, add tests for those too.
  </action>
  <verify>
```bash
npm run test -- src/lib/__tests__/rate-limit.test.ts --run
```
  </verify>
  <done>
- Test file created at src/lib/__tests__/rate-limit.test.ts
- Tests for isAdminExempt and getRateLimitIdentifier pass
- Uses vitest conventions from project
  </done>
</task>

<task type="auto">
  <name>Task 2: Create webhook security tests</name>
  <files>src/lib/__tests__/webhook-security.test.ts</files>
  <action>
Create `src/lib/__tests__/webhook-security.test.ts` with tests for signature verification.

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import crypto from "crypto";
import { verifyWebhookSignature, verifyGrowProcessToken } from "../webhook-security";

describe("webhook-security", () => {
  const SECRET = "test-webhook-secret";

  describe("verifyWebhookSignature", () => {
    it("should return invalid for missing signature", () => {
      const result = verifyWebhookSignature("payload", null, SECRET);
      expect(result.valid).toBe(false);
      expect(result.error).toBe("Missing signature");
    });

    it("should return invalid for empty signature", () => {
      const result = verifyWebhookSignature("payload", "", SECRET);
      expect(result.valid).toBe(false);
      expect(result.error).toBe("Missing signature");
    });

    it("should validate correct signature", () => {
      const payload = '{"test": "data"}';
      const hmac = crypto.createHmac("sha256", SECRET);
      const signature = hmac.update(payload).digest("hex");

      const result = verifyWebhookSignature(payload, signature, SECRET);
      expect(result.valid).toBe(true);
      expect(result.error).toBeUndefined();
    });

    it("should reject incorrect signature", () => {
      const payload = '{"test": "data"}';
      const wrongSignature = "0".repeat(64);

      const result = verifyWebhookSignature(payload, wrongSignature, SECRET);
      expect(result.valid).toBe(false);
      expect(result.error).toBe("Signature mismatch");
    });

    it("should reject signature with wrong length", () => {
      const payload = '{"test": "data"}';
      const shortSignature = "abc123";

      const result = verifyWebhookSignature(payload, shortSignature, SECRET);
      expect(result.valid).toBe(false);
    });

    describe("with timestamp", () => {
      beforeEach(() => {
        vi.useFakeTimers();
        vi.setSystemTime(new Date("2024-01-15T12:00:00Z"));
      });

      afterEach(() => {
        vi.useRealTimers();
      });

      it("should validate with current timestamp", () => {
        const timestamp = Math.floor(Date.now() / 1000).toString();
        const payload = '{"test": "data"}';
        const signedPayload = `${timestamp}.${payload}`;
        const hmac = crypto.createHmac("sha256", SECRET);
        const signature = hmac.update(signedPayload).digest("hex");

        const result = verifyWebhookSignature(payload, signature, SECRET, timestamp);
        expect(result.valid).toBe(true);
      });

      it("should reject old timestamp (replay attack)", () => {
        const oldTimestamp = (Math.floor(Date.now() / 1000) - 600).toString(); // 10 min ago
        const payload = '{"test": "data"}';
        const signedPayload = `${oldTimestamp}.${payload}`;
        const hmac = crypto.createHmac("sha256", SECRET);
        const signature = hmac.update(signedPayload).digest("hex");

        const result = verifyWebhookSignature(payload, signature, SECRET, oldTimestamp);
        expect(result.valid).toBe(false);
        expect(result.error).toBe("Timestamp out of range");
      });

      it("should reject future timestamp", () => {
        const futureTimestamp = (Math.floor(Date.now() / 1000) + 600).toString(); // 10 min future
        const payload = '{"test": "data"}';

        const result = verifyWebhookSignature(payload, "any", SECRET, futureTimestamp);
        expect(result.valid).toBe(false);
        expect(result.error).toBe("Timestamp out of range");
      });

      it("should reject invalid timestamp format", () => {
        const result = verifyWebhookSignature("payload", "sig", SECRET, "not-a-number");
        expect(result.valid).toBe(false);
        expect(result.error).toBe("Invalid timestamp");
      });
    });
  });

  describe("verifyGrowProcessToken", () => {
    it("should return true for matching tokens", () => {
      expect(verifyGrowProcessToken("token123", "token123")).toBe(true);
    });

    it("should return false for non-matching tokens", () => {
      expect(verifyGrowProcessToken("token123", "token456")).toBe(false);
    });

    it("should return false for null stored token", () => {
      expect(verifyGrowProcessToken("token123", null)).toBe(false);
    });

    it("should return false for empty tokens", () => {
      expect(verifyGrowProcessToken("", "")).toBe(false);
    });
  });
});
```
  </action>
  <verify>
```bash
npm run test -- src/lib/__tests__/webhook-security.test.ts --run
```
  </verify>
  <done>
- Test file created at src/lib/__tests__/webhook-security.test.ts
- Tests for signature verification pass
- Tests for replay attack protection pass
- Tests for processToken validation pass
  </done>
</task>

<task type="auto">
  <name>Task 3: Create validation schema tests</name>
  <files>src/lib/validations/__tests__/payment.test.ts, src/lib/validations/__tests__/webhook.test.ts</files>
  <action>
Create test files for Zod validation schemas.

**src/lib/validations/__tests__/payment.test.ts:**

```typescript
import { describe, it, expect } from "vitest";
import { createPaymentSchema, formatZodErrors } from "../payment";

describe("createPaymentSchema", () => {
  const validPayment = {
    amount: 100,
    description: "Test payment",
    paymentType: "one_time" as const,
    payerName: "יוסי כהן",
    payerPhone: "0501234567",
    payerEmail: "test@example.com",
  };

  it("should accept valid payment data", () => {
    const result = createPaymentSchema.safeParse(validPayment);
    expect(result.success).toBe(true);
  });

  it("should reject negative amount", () => {
    const result = createPaymentSchema.safeParse({
      ...validPayment,
      amount: -100,
    });
    expect(result.success).toBe(false);
  });

  it("should reject zero amount", () => {
    const result = createPaymentSchema.safeParse({
      ...validPayment,
      amount: 0,
    });
    expect(result.success).toBe(false);
  });

  it("should reject missing description", () => {
    const result = createPaymentSchema.safeParse({
      ...validPayment,
      description: "",
    });
    expect(result.success).toBe(false);
  });

  it("should reject invalid payment type", () => {
    const result = createPaymentSchema.safeParse({
      ...validPayment,
      paymentType: "invalid",
    });
    expect(result.success).toBe(false);
  });

  describe("payerName validation", () => {
    it("should reject single name (no last name)", () => {
      const result = createPaymentSchema.safeParse({
        ...validPayment,
        payerName: "יוסי",
      });
      expect(result.success).toBe(false);
    });

    it("should reject short name parts", () => {
      const result = createPaymentSchema.safeParse({
        ...validPayment,
        payerName: "י כ",
      });
      expect(result.success).toBe(false);
    });

    it("should accept full Hebrew name", () => {
      const result = createPaymentSchema.safeParse({
        ...validPayment,
        payerName: "יוסף כהן",
      });
      expect(result.success).toBe(true);
    });
  });

  describe("payerPhone validation", () => {
    it("should reject non-Israeli phone", () => {
      const result = createPaymentSchema.safeParse({
        ...validPayment,
        payerPhone: "1234567890",
      });
      expect(result.success).toBe(false);
    });

    it("should reject phone with wrong prefix", () => {
      const result = createPaymentSchema.safeParse({
        ...validPayment,
        payerPhone: "0701234567",
      });
      expect(result.success).toBe(false);
    });

    it("should accept valid Israeli mobile", () => {
      const result = createPaymentSchema.safeParse({
        ...validPayment,
        payerPhone: "0521234567",
      });
      expect(result.success).toBe(true);
    });
  });

  describe("optional fields", () => {
    it("should accept payment without email", () => {
      const { payerEmail, ...noEmail } = validPayment;
      const result = createPaymentSchema.safeParse(noEmail);
      expect(result.success).toBe(true);
    });

    it("should accept empty email string", () => {
      const result = createPaymentSchema.safeParse({
        ...validPayment,
        payerEmail: "",
      });
      expect(result.success).toBe(true);
    });

    it("should reject invalid email format", () => {
      const result = createPaymentSchema.safeParse({
        ...validPayment,
        payerEmail: "not-an-email",
      });
      expect(result.success).toBe(false);
    });
  });
});

describe("formatZodErrors", () => {
  it("should format errors by field path", () => {
    const result = createPaymentSchema.safeParse({
      amount: -1,
      description: "",
      paymentType: "invalid",
      payerName: "x",
      payerPhone: "123",
    });

    if (result.success) {
      throw new Error("Expected validation to fail");
    }

    const formatted = formatZodErrors(result.error);
    expect(formatted.amount).toBeDefined();
    expect(formatted.description).toBeDefined();
    expect(formatted.payerPhone).toBeDefined();
  });
});
```

**src/lib/validations/__tests__/webhook.test.ts:**

```typescript
import { describe, it, expect } from "vitest";
import { growWebhookSchema, safeParseInt, safeParseFloat } from "../webhook";

describe("growWebhookSchema", () => {
  const validWebhook = {
    status: "1",
    data: {
      processId: "proc-123",
      processToken: "token-456",
      statusCode: "2",
    },
  };

  it("should accept valid webhook payload", () => {
    const result = growWebhookSchema.safeParse(validWebhook);
    expect(result.success).toBe(true);
  });

  it("should reject missing processId", () => {
    const result = growWebhookSchema.safeParse({
      status: "1",
      data: {
        processToken: "token-456",
        statusCode: "2",
      },
    });
    expect(result.success).toBe(false);
  });

  it("should reject missing processToken", () => {
    const result = growWebhookSchema.safeParse({
      status: "1",
      data: {
        processId: "proc-123",
        statusCode: "2",
      },
    });
    expect(result.success).toBe(false);
  });

  describe("numeric string parsing", () => {
    it("should parse valid paymentsNum", () => {
      const result = growWebhookSchema.safeParse({
        ...validWebhook,
        data: {
          ...validWebhook.data,
          paymentsNum: "5",
        },
      });
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.data.paymentsNum).toBe(5);
      }
    });

    it("should default paymentsNum to 1 for invalid input", () => {
      const result = growWebhookSchema.safeParse({
        ...validWebhook,
        data: {
          ...validWebhook.data,
          paymentsNum: "not-a-number",
        },
      });
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.data.paymentsNum).toBe(1);
      }
    });

    it("should parse firstPaymentSum as float", () => {
      const result = growWebhookSchema.safeParse({
        ...validWebhook,
        data: {
          ...validWebhook.data,
          firstPaymentSum: "99.50",
        },
      });
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.data.firstPaymentSum).toBeCloseTo(99.5);
      }
    });

    it("should return null for invalid firstPaymentSum", () => {
      const result = growWebhookSchema.safeParse({
        ...validWebhook,
        data: {
          ...validWebhook.data,
          firstPaymentSum: "invalid",
        },
      });
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.data.firstPaymentSum).toBeNull();
      }
    });
  });
});

describe("safeParseInt", () => {
  it("should parse valid integer string", () => {
    expect(safeParseInt("42", 0)).toBe(42);
  });

  it("should return default for invalid string", () => {
    expect(safeParseInt("abc", 1)).toBe(1);
  });

  it("should return default for undefined", () => {
    expect(safeParseInt(undefined, 5)).toBe(5);
  });

  it("should return default for empty string", () => {
    expect(safeParseInt("", 10)).toBe(10);
  });
});

describe("safeParseFloat", () => {
  it("should parse valid float string", () => {
    expect(safeParseFloat("3.14", 0)).toBeCloseTo(3.14);
  });

  it("should return default for invalid string", () => {
    expect(safeParseFloat("xyz", null)).toBeNull();
  });

  it("should return default for undefined", () => {
    expect(safeParseFloat(undefined, 0)).toBe(0);
  });
});
```
  </action>
  <verify>
```bash
npm run test -- src/lib/validations/__tests__/ --run
npm run test:run  # Run all tests
```
  </verify>
  <done>
- Payment validation tests created and pass
- Webhook validation tests created and pass
- Safe number parsing tests pass
- All tests run successfully
  </done>
</task>

</tasks>

<verification>
1. Rate limit tests pass: `npm run test -- src/lib/__tests__/rate-limit.test.ts --run`
2. Webhook security tests pass: `npm run test -- src/lib/__tests__/webhook-security.test.ts --run`
3. Validation tests pass: `npm run test -- src/lib/validations/__tests__/ --run`
4. All tests pass: `npm run test:run`
</verification>

<success_criteria>
- src/lib/__tests__/rate-limit.test.ts exists with passing tests
- src/lib/__tests__/webhook-security.test.ts exists with passing tests
- src/lib/validations/__tests__/payment.test.ts exists with passing tests
- src/lib/validations/__tests__/webhook.test.ts exists with passing tests
- All tests pass with npm run test:run
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-fixes/01-06-SUMMARY.md`
</output>
