---
phase: 01-security-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/rate-limit.ts
  - src/lib/webhook-security.ts
autonomous: true
user_setup:
  - service: upstash
    why: "Distributed rate limiting across serverless instances"
    env_vars:
      - name: UPSTASH_REDIS_REST_URL
        source: "Upstash Console -> Create Database -> REST API -> UPSTASH_REDIS_REST_URL"
      - name: UPSTASH_REDIS_REST_TOKEN
        source: "Upstash Console -> Create Database -> REST API -> UPSTASH_REDIS_REST_TOKEN"
    dashboard_config:
      - task: "Create a Redis database"
        location: "https://console.upstash.com -> Create Database -> Choose closest region to Vercel deployment"

must_haves:
  truths:
    - "Rate limiting utility can check limits and return success/failure"
    - "Webhook verification can validate HMAC signatures"
    - "Admin users can be exempted from rate limits"
  artifacts:
    - path: "src/lib/rate-limit.ts"
      provides: "Rate limiting utilities"
      exports: ["checkRateLimit", "isAdminExempt"]
      min_lines: 40
    - path: "src/lib/webhook-security.ts"
      provides: "Webhook signature verification"
      exports: ["verifyWebhookSignature"]
      min_lines: 30
  key_links:
    - from: "src/lib/rate-limit.ts"
      to: "@upstash/ratelimit"
      via: "Ratelimit class import"
      pattern: "from.*@upstash/ratelimit"
---

<objective>
Create security infrastructure utilities for rate limiting and webhook verification.

Purpose: Establish foundational security primitives that other plans will use to secure API endpoints and webhooks.
Output: Rate limiting utility with Upstash Redis, webhook signature verification with HMAC-SHA256.
</objective>

<execution_context>
@/Users/itayostraich/.claude/get-shit-done/workflows/execute-plan.md
@/Users/itayostraich/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-fixes/01-CONTEXT.md
@.planning/phases/01-security-fixes/01-RESEARCH.md
@src/middleware.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install security dependencies</name>
  <files>package.json</files>
  <action>
Install the rate limiting and background processing packages:
```bash
npm install @upstash/ratelimit @upstash/redis @vercel/functions
```

These packages enable:
- `@upstash/ratelimit`: Distributed rate limiting with sliding window algorithm
- `@upstash/redis`: REST-based Redis client for edge/serverless
- `@vercel/functions`: `waitUntil` for background analytics processing
  </action>
  <verify>Run `npm ls @upstash/ratelimit @upstash/redis @vercel/functions` - all packages should be listed</verify>
  <done>All three packages installed and in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create rate limiting utility</name>
  <files>src/lib/rate-limit.ts</files>
  <action>
Create `src/lib/rate-limit.ts` with the following:

1. Import dependencies:
   - `Ratelimit` from `@upstash/ratelimit`
   - `Redis` from `@upstash/redis`

2. Create two rate limiters:
   - `paymentLimiter`: 10 requests per hour (sliding window)
   - `generalLimiter`: 100 requests per minute (sliding window)

3. Export `checkRateLimit` function that:
   - Takes `identifier` (user ID or IP) and `type` ('payment' | 'general')
   - Returns `{ rateLimited: boolean, limit: number, remaining: number, pending: Promise }`
   - Uses sliding window algorithm

4. Export `isAdminExempt` helper that:
   - Takes user role
   - Returns true if role is 'admin' (admins bypass all rate limits)

5. Export `getRateLimitIdentifier` helper that:
   - Takes userId (nullable) and IP
   - Returns userId if authenticated, otherwise `ip:${ip}`

Configuration:
- Prefix: "goe" (garden of eden)
- Analytics: enabled
- Use `Redis.fromEnv()` which reads UPSTASH_REDIS_REST_URL and UPSTASH_REDIS_REST_TOKEN

Error handling:
- If Redis connection fails, log error but DON'T block the request (fail open for availability)
- This is a security tradeoff: prefer availability over blocking legitimate users
  </action>
  <verify>
Run TypeScript check: `npx tsc --noEmit src/lib/rate-limit.ts`
Verify file exports: `grep -E "export (async )?function" src/lib/rate-limit.ts`
  </verify>
  <done>
- `src/lib/rate-limit.ts` exists with checkRateLimit, isAdminExempt, getRateLimitIdentifier exports
- TypeScript compiles without errors
- Uses @upstash/ratelimit with sliding window
  </done>
</task>

<task type="auto">
  <name>Task 3: Create webhook security utility</name>
  <files>src/lib/webhook-security.ts</files>
  <action>
Create `src/lib/webhook-security.ts` with the following:

1. Import Node.js crypto module

2. Export `verifyWebhookSignature` function that:
   - Takes: rawBody (string), signature (string | null), secret (string), timestamp (string | null), toleranceSeconds (default 300)
   - Returns: `{ valid: boolean, error?: string }`

Implementation:
- If signature is missing, return `{ valid: false, error: "Missing signature" }`
- Replay protection: If timestamp provided, validate it's within toleranceSeconds of now
  - Parse with `parseInt(timestamp, 10)`
  - If `isNaN()`, return `{ valid: false, error: "Invalid timestamp" }`
  - If `Math.abs(now - webhookTime) > toleranceSeconds`, return `{ valid: false, error: "Timestamp out of range" }`
- Compute expected signature:
  - Payload = timestamp ? `${timestamp}.${rawBody}` : rawBody
  - HMAC-SHA256 with secret, output as hex
- Use `crypto.timingSafeEqual()` for comparison (prevents timing attacks)
  - First check buffer lengths match
  - Then use timingSafeEqual
- Return `{ valid: true }` on success

3. Export `verifyGrowWebhook` convenience wrapper that:
   - Takes rawBody and headers object
   - Extracts signature from `x-grow-signature` or `x-webhook-signature` header
   - Extracts timestamp from `x-grow-timestamp` or `x-webhook-timestamp` header
   - Uses `process.env.GROW_WEBHOOK_SECRET`
   - Calls verifyWebhookSignature

Note: GROW webhook signature format is uncertain (see RESEARCH.md). Implement standard HMAC-SHA256 pattern and also add `verifyGrowProcessToken` as fallback that validates processToken from payload against stored value.
  </action>
  <verify>
Run TypeScript check: `npx tsc --noEmit src/lib/webhook-security.ts`
Verify exports: `grep -E "export (async )?function" src/lib/webhook-security.ts`
  </verify>
  <done>
- `src/lib/webhook-security.ts` exists with verifyWebhookSignature, verifyGrowWebhook, verifyGrowProcessToken exports
- Uses crypto.timingSafeEqual for timing-safe comparison
- Includes replay protection via timestamp validation
  </done>
</task>

</tasks>

<verification>
1. All packages installed: `npm ls @upstash/ratelimit @upstash/redis @vercel/functions`
2. Rate limit utility compiles: `npx tsc --noEmit src/lib/rate-limit.ts`
3. Webhook security utility compiles: `npx tsc --noEmit src/lib/webhook-security.ts`
4. No lint errors: `npm run lint`
</verification>

<success_criteria>
- @upstash/ratelimit, @upstash/redis, @vercel/functions in package.json
- src/lib/rate-limit.ts exports checkRateLimit, isAdminExempt, getRateLimitIdentifier
- src/lib/webhook-security.ts exports verifyWebhookSignature, verifyGrowWebhook, verifyGrowProcessToken
- TypeScript compiles without errors
- ESLint passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-fixes/01-01-SUMMARY.md`
</output>
